{# app/workshop/templates/workshop_lobby.html #}
{% extends "main_template.html" %}
{% block title %}Lobby: {{ workshop.title }}{% endblock %}

{% block content %}
<div class="container mt-4">
  <div class="card shadow-sm">

    <div class="card-header bg-info text-dark d-flex align-items-center flex-wrap gap-2">
      <h1 class="h4 mb-0 flex-grow-1">Workshop Lobby: {{ workshop.title }}</h1>
      <div class="d-flex gap-2 ms-auto">
        <a href="{{ url_for('workshop_bp.view_workshop', workshop_id=workshop.id) }}" class="btn btn-sm btn-outline-light">
          <i class="bi bi-box-arrow-left"></i>
          <span class="d-none d-md-inline">Leave Lobby</span>
        </a>
        {% if current_user.user_id == workshop.created_by_id %}
        <form id="start-workshop-form" method="POST" action="{{ url_for('workshop_bp.start_workshop', workshop_id=workshop.id) }}" class="d-inline">
          <button type="submit" class="btn btn-sm btn-danger">
            <i class="bi bi-play-fill"></i>
            <span class="d-none d-md-inline">Start Workshop</span>
          </button>
        </form>
        {% endif %}
      </div>
    </div>

    <div class="card-body">
      <!-- âœ¨ Top row -->
      <div class="row g-3 mb-4">
        <!-- Organizer / Schedule -->
        <div class="col-12 col-md-4">
          <div class="p-3 border rounded bg-light h-100 d-flex flex-column justify-content-between">
            <div>
              <p class="mb-2"><strong>Organizer:</strong><br>{{ workshop.organizer.first_name or workshop.creator.email }}</p>
              <p class="mb-2"><strong>Scheduled:</strong><br>{{ workshop.date_time.strftime('%Y-%m-%d %H:%M') }}â€¯UTC</p>
              <p class="mb-2"><strong>Duration:</strong><br>{{ workshop.duration or 'N/A' }}â€¯minutes</p>
              <p id="countdown-{{ workshop.id }}" class="mb-2"><strong>Starts in:</strong> <span class="badge bg-success text-white">Loadingâ€¦</span></p>
              <p class="mb-0"><strong>Members Joined:</strong> <span class="badge bg-success" id="participant-count">{{ participants | length }}</span></p>
            </div>
          </div>
        </div>

        {# --- Rules Service --- #}
        {% include 'service_rules.html' %}
        {# --- End Rules Service --- #}

        <!-- Icebreaker & Tip -->
        <div class="col-12 col-md-4">
          <div class="p-3 border rounded bg-light h-100 d-flex flex-column"> {# Removed justify-content-between #}

            {# --- Icebreaker Service --- #}
            {% include 'service_icebreaker.html' %}
            {# --- End Icebreaker Service --- #}

            {# --- Tip Service --- #}
            {% include 'service_tip.html' %}
            {# --- End Tip Service --- #}

          </div>
        </div>
      </div>

      <!-- ðŸ”— Middle row (Agenda & Documents) -->
      <div class="row g-3 mb-4">
        <!-- Agenda -->
        
        <div class="col-12 col-lg-5 d-flex flex-column"> {# Added d-flex flex-column #}
          <h5 class="mt-3 mt-lg-0">Agenda</h5>
          {# --- Agenda Service --- #}
          {% include 'service_agenda.html' %}
          {# --- End Agenda Service --- #}
        </div>


        <!-- Documents -->
        <div class="col-12 col-lg-7">
          <h5 class="mt-3 mt-lg-0">Documents</h5>
          <div class="border rounded p-3 bg-light h-100 overflow-auto">
            {% if linked_documents %}
            <ul class="list-group list-group-flush">
              {% for link in linked_documents %}
              <li class="list-group-item bg-light d-flex justify-content-between align-items-start flex-wrap gap-2">
                <span class="me-2 flex-grow-1">
                  <i class="bi bi-file-earmark-text me-2"></i>{{ link.document.title or link.document.file_name }}
                  {% if link.document.description %}<small class="text-muted d-block">{{ link.document.description }}</small>{% endif %}
                </span>
                <a href="{{ url_for('document_bp.preview_document', document_id=link.document.id) }}" class="btn btn-sm btn-outline-secondary" title="Preview Document">
                  <i class="bi bi-eye"></i>
                </a>
              </li>
              {% endfor %}
            </ul>
            {% else %}
            <p class="text-muted mb-0">No documents linked to this workshop yet.</p>
            {% endif %}
          </div>
        </div>
      </div>

      <!-- ðŸ‘¥ Participants -->
      <div class="row g-3 mb-4">
        <div class="col-12">
          <h5 class="mt-4">Participants (<span id="participant-count-display">{{ participants | length }}</span>)</h5> {# Updated ID #}
          <ul class="list-group mb-4" id="participant-list">
            {% for p in participants %}
            <li class="list-group-item d-flex justify-content-between align-items-center flex-wrap gap-2" id="participant-{{ p.user_id }}"> {# Add ID #}
              <span class="d-flex align-items-center gap-2 flex-grow-1">
                <img src="{{ url_for('static', filename='images/default-profile.png') }}" alt="pic" class="rounded-circle" style="width:30px;height:30px;object-fit:cover;">
                {{ p.user.first_name or p.user.email }}
                {% if p.role == 'organizer' or p.user_id == workshop.created_by_id %}<span class="badge bg-primary">Organizer</span>{% endif %}
              </span>
              <span class="badge bg-secondary" id="status-{{ p.user_id }}">Waiting</span>
            </li>
            {% endfor %}
          </ul>
        </div>
      </div>

      <div class="text-center mb-2">
        <p class="lead mb-3">Please wait for the organizer to start the workshop.</p>
        <div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loadingâ€¦</span></div>
      </div>
    </div> {# End card-body #}
  </div> {# End card #}
</div> {# End container #}


<!-- Edit Modal -->
{% if user_is_organizer %}
<div class="modal fade" id="editModal" tabindex="-1" aria-labelledby="editModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="editModalLabel">Edit Content</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <input type="hidden" id="edit-type">
        <div class="mb-3">
          <label for="edit-content-area" class="form-label">Content (Markdown supported)</label>
          <textarea class="form-control" id="edit-content-area" rows="10"></textarea>
        </div>
        <div id="edit-error" class="text-danger small mt-2"></div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="save-edit-btn">Save Changes</button>
      </div>
    </div>
  </div>
</div>
{% endif %}
<!-- End Edit Modal -->

<script>
  // --- Constants ---
  const workshopId = {{ workshop.id }};
  const userId = {{ current_user.user_id }};
  const isOrganizer = {{ user_is_organizer | tojson }}; // Pass boolean to JS
  const lobbyRoom = `workshop_lobby_${workshopId}`;
  const defaultProfilePicUrl = "{{ url_for('static', filename='images/default-profile.png') }}";
  // --- Socket.IO Setup ---
  const socket = io(); // Assuming connection is established in base.html

  socket.on('connect', () => {
    console.log('Socket connected');
    socket.emit('join_room', { room: lobbyRoom, workshop_id: workshopId, user_id: userId });
    console.log(`Joined Socket.IO room: ${lobbyRoom}`);
  });

  socket.on('disconnect', () => {
    console.log('Socket disconnected');
  });

  // --- Event Listeners ---
  document.addEventListener('DOMContentLoaded', () => {
      setupStartWorkshopForm();
      setupCountdown();
      if (isOrganizer) {
          setupAdminControls();
          setupEditModal();
      }
  });

  window.addEventListener('beforeunload', () => {
      socket.emit('leave_room', { room: lobbyRoom });
      console.log(`Left Socket.IO room: ${lobbyRoom}`);
  });

  // --- Socket Event Handlers ---
  socket.on('workshop_started', (data) => handleWorkshopStarted(data));
  socket.on('participant_update', (data) => handleParticipantUpdate(data)); // Generic status update
  socket.on('participant_list_update', (data) => handleParticipantListUpdate(data)); // Full list refresh
  socket.on('ai_content_update', (data) => {
    console.log('AI content update received:', data);
    if (data.workshop_id === workshopId && data.type && data.content) {
        let elementId;
        switch (data.type) {
            case 'agenda':
                elementId = 'agenda-titles-list'; // ID for agenda list
                break;
            case 'rules':
                elementId = 'ai-rules-content'; // ID for rules content
                break;
            case 'icebreaker':
                elementId = 'ai-icebreaker-content'; // ID for icebreaker content
                break;
            case 'tip':
                elementId = 'ai-tip-content'; // ID for tip content
                break;
            default:
                console.warn(`Unknown AI content type received: ${data.type}`);
                return;
        }

        const element = document.getElementById(elementId);
        if (element) {
            if (data.type === 'agenda') {
                // Update agenda list dynamically
                try {
                    const agendaItems = JSON.parse(data.content).agenda || [];
                    element.innerHTML = ''; // Clear existing content
                    agendaItems.forEach(item => {
                        const li = document.createElement('li');
                        li.className = 'list-group-item';
                        li.textContent = item.activity; // Use the "activity" field
                        element.appendChild(li);
                    });
                } catch (e) {
                    console.error('Failed to parse agenda JSON:', e);
                }
            } else {
                // Update other content types directly
                element.innerHTML = data.content;
            }
            console.log(`Updated UI for ${data.type}`);
        } else {
            console.warn(`Element with ID '${elementId}' not found for AI content type: ${data.type}`);
        }
    }
  });

  // --- Helper Functions ---

  function setupStartWorkshopForm() {
      const startForm = document.getElementById('start-workshop-form');
      if (!startForm) return;

      startForm.addEventListener('submit', async (e) => {
          e.preventDefault();
          const button = startForm.querySelector('button[type="submit"]');
          button.disabled = true;
          button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Starting...';

          try {
              const res = await fetch(startForm.action, {
                  method: 'POST',
                  headers: {
                      'X-Requested-With': 'XMLHttpRequest',
                      'Accept': 'application/json' // Ensure server knows we want JSON
                  }
              });
              const payload = await res.json();
              if (res.ok && payload.success && payload.redirect_url) {
                  window.location.href = payload.redirect_url;
              } else {
                  throw new Error(payload.message || `HTTP error! status: ${res.status}`);
              }
          } catch (err) {
              console.error('Start workshop error:', err);
              alert('Could not start workshop: ' + err.message);
              button.disabled = false;
               button.innerHTML = '<i class="bi bi-play-fill"></i> <span class="d-none d-md-inline">Start Workshop</span>';
          }
      });
  }

  function setupCountdown() {
      const countdownElement = document.querySelector(`#countdown-${workshopId} span`);
      if (!countdownElement) return;
      const startTime = new Date("{{ workshop.date_time.isoformat() }}Z").getTime();

      const intervalId = setInterval(() => {
          const now = Date.now();
          const diff = startTime - now;

          if (diff <= 0) {
              countdownElement.textContent = 'Now!';
              countdownElement.classList.remove('bg-success');
              countdownElement.classList.add('bg-warning');
              clearInterval(intervalId);
              return;
          }

          const days = Math.floor(diff / (1000 * 60 * 60 * 24));
          const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
          const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
          const seconds = Math.floor((diff % (1000 * 60)) / 1000);

          const parts = [];
          if (days) parts.push(`${days}d`);
          if (hours) parts.push(`${hours}h`);
          if (minutes) parts.push(`${minutes}m`);
          parts.push(`${seconds}s`);

          countdownElement.textContent = parts.join(' ') || '0s';
      }, 1000);
  }

  function setupAdminControls() {
      document.querySelectorAll('.regenerate-btn').forEach(button => {
          button.addEventListener('click', handleRegenerateClick);
      });
      // Edit buttons are handled by Bootstrap modal trigger, logic is in setupEditModal
  }

  async function handleRegenerateClick(event) {
      const button = event.currentTarget;
      const type = button.dataset.type; // 'rules', 'icebreaker', 'tip', 'agenda'
      if (!type) return;

      button.disabled = true;
      button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';

      const url = `/workshop/${workshopId}/regenerate/${type}`;
      try {
          const response = await fetch(url, {
              method: 'POST',
              headers: {
                  'X-Requested-With': 'XMLHttpRequest',
                  'Accept': 'application/json'
              }
          });
          const data = await response.json();

          if (response.ok && data.success) {
              // Success! The UI update will be handled by the 'ai_content_update' socket event
              console.log(`${type} regeneration request successful. Waiting for update via socket.`);
          } else {
              throw new Error(data.message || `HTTP error ${response.status}`);
          }
      } catch (error) {
        console.error(`Error requesting regeneration for ${type}:`, error);
        // Display a more specific error if available from the server
        alert(`Could not regenerate ${type}: ${error.message || 'Request failed.'}`);
      } finally {
          button.disabled = false;
          // Restore original button text/icon
          button.innerHTML = '<i class="bi bi-arrow-clockwise"></i> <span class="d-none d-md-inline">Regenerate</span>';
      }
  }

  function setupEditModal() {
      const editModal = document.getElementById('editModal');
      if (!editModal) return;
      const modal = new bootstrap.Modal(editModal); // Get Bootstrap modal instance

      const editContentArea = document.getElementById('edit-content-area');
      const editTypeInput = document.getElementById('edit-type');
      const saveButton = document.getElementById('save-edit-btn');
      const errorDiv = document.getElementById('edit-error');

      // When modal is shown, populate it with current content
      editModal.addEventListener('show.bs.modal', (event) => {
          const button = event.relatedTarget; // Button that triggered the modal
          const type = button.dataset.type;
          editTypeInput.value = type;
          errorDiv.textContent = ''; // Clear previous errors

          // Fetch current RAW content (requires a new endpoint or storing raw content in JS)
          // For simplicity, let's grab the HTML and try to reverse it (less ideal)
          // A better way: Store raw markdown in a hidden data attribute or fetch it
          
          // Use the correct ID for agenda content
          const contentElementId = (type === 'agenda') ? 'ai-agenda-content' : `ai-${type}-content`;
          
          const contentElement = document.getElementById(`ai-${type}-content`);
          // This is a basic attempt, might need refinement based on actual content
          let currentContent = contentElement.innerHTML.trim();
          if (type === 'icebreaker') {
              // Try to extract text from blockquote
              const blockquote = contentElement.querySelector('blockquote');
              if (blockquote) currentContent = blockquote.textContent.trim();
          }
          // Basic HTML tag stripping (replace with a proper library if needed)
          // This might mangle Markdown if it contains HTML-like syntax
          // A better approach is needed for true Markdown editing
          currentContent = currentContent.replace(/<[^>]*>/g, (match) => {
              // Keep line breaks for basic structure
              if (match === '<br>' || match === '<br/>' || match === '<p>' || match === '</li>') return '\n';
              return '';
          }).replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>'); // Decode basic entities


          editContentArea.value = currentContent; // Set text area value
          document.getElementById('editModalLabel').textContent = `Edit ${capitalizeFirstLetter(type)}`;
      });

      // Handle save button click
      saveButton.addEventListener('click', async () => {
          const type = editTypeInput.value;
          const content = editContentArea.value;
          const url = `/workshop/${workshopId}/edit/${type}`;

          saveButton.disabled = true;
          saveButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Saving...';
          errorDiv.textContent = '';

          try {
              const response = await fetch(url, {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json',
                      'X-Requested-With': 'XMLHttpRequest',
                      'Accept': 'application/json'
                  },
                  body: JSON.stringify({ content: content })
              });
              const data = await response.json();

              if (response.ok && data.success) {
                  // Update UI via socket event 'ai_content_update'
                  console.log(`${type} edited successfully.`);
                  modal.hide(); // Close modal on success
              } else {
                  throw new Error(data.message || `HTTP error ${response.status}`);
              }
          } catch (error) {
              console.error(`Error saving edited ${type}:`, error);
              errorDiv.textContent = `Error: ${error.message}`;
          } finally {
              saveButton.disabled = false;
              saveButton.innerHTML = 'Save Changes';
          }
      });
  }

  function handleWorkshopStarted(data) {
      console.log('Workshop started event received:', data);
      if (data.workshop_id === workshopId) {
          window.location.href = "{{ url_for('workshop_bp.workshop_room', workshop_id=workshop.id) }}";
      }
  }

  function handleParticipantUpdate(data) {
      console.log('Participant update received:', data);
      if (data.workshop_id === workshopId) {
          const statusBadge = document.getElementById(`status-${data.user_id}`);
          if (statusBadge) {
              statusBadge.textContent = data.status;
              // Optional: Update badge class based on status
              // statusBadge.className = `badge bg-${getBadgeClass(data.status)}`;
          }
      }
  }

  function handleParticipantListUpdate(data) {
      console.log('Participant list update received:', data);
      if (data.workshop_id === workshopId) {
          const listElement = document.getElementById('participant-list');
          const countElement = document.getElementById('participant-count-display'); // Use updated ID
          if (!listElement || !countElement) return;

          listElement.innerHTML = ''; // Clear existing list
          data.participants.forEach(p => {
              const li = document.createElement('li');
              li.className = 'list-group-item d-flex justify-content-between align-items-center flex-wrap gap-2';
              li.id = `participant-${p.user_id}`;
              li.innerHTML = `
                              <span class="d-flex align-items-center gap-2 flex-grow-1"> 
                                  <img src="${p.profile_pic_url || defaultProfilePicUrl}" alt="pic" class="rounded-circle" style="width:30px;height:30px;object-fit:cover;">
                                  ${p.first_name || p.email}
                                  ${p.is_organizer ? '<span class="badge bg-primary ms-2">Organizer</span>' : ''}
                              </span>
                              <span class="badge bg-secondary" id="status-${p.user_id}">${p.status || 'Waiting'}</span>
                          `;
              listElement.appendChild(li);
          });
          countElement.textContent = data.participants.length;


          
          // Also update the count in the top section if it exists
          const topCountElement = document.getElementById('participant-count');
           if (topCountElement) topCountElement.textContent = data.participants.length;
      }
  }

  function handleAiContentUpdate(data) {
    console.log('AI content update received:', data);
    if (data.workshop_id === workshopId && data.type && data.content) {
        let elementId;
        switch (data.type) {
            case 'agenda':
                elementId = 'agenda-titles-list'; // ID for agenda list
                break;
            case 'rules':
                elementId = 'ai-rules-content'; // ID for rules content
                break;
            case 'icebreaker':
                elementId = 'ai-icebreaker-content'; // ID for icebreaker content
                break;
            case 'tip':
                elementId = 'ai-tip-content'; // ID for tip content
                break;
            default:
                console.warn(`Unknown AI content type received: ${data.type}`);
                return;
        }

        const element = document.getElementById(elementId);
        if (element) {
            if (data.type === 'agenda') {
                // Update agenda list dynamically
                try {
                    const agendaItems = JSON.parse(data.content).agenda || [];
                    element.innerHTML = ''; // Clear existing content
                    agendaItems.forEach(item => {
                        const li = document.createElement('li');
                        li.className = 'list-group-item';
                        li.textContent = item.activity; // Use the "activity" field
                        element.appendChild(li);
                    });
                } catch (e) {
                    console.error('Failed to parse agenda JSON:', e);
                }
            } else {
                // Update other content types directly
                element.innerHTML = data.content;
            }
            console.log(`Updated UI for ${data.type}`);
        } else {
            console.warn(`Element with ID '${elementId}' not found for AI content type: ${data.type}`);
        }
    }
  }

  function updateAiContentElement(type, htmlContent) {
      // Use the new ID for agenda
      const elementId = (type === 'agenda') ? 'ai-agenda-content' : `ai-${type}-content`;
     
      const element = document.getElementById(`ai-${type}-content`);
      if (element) {
          // Special handling for icebreaker blockquote
          if (type === 'icebreaker') {
              const blockquote = element.querySelector('blockquote');
              if (blockquote) {
                  blockquote.innerHTML = htmlContent; // Update inner HTML of blockquote
              } else {
                   // Fallback if blockquote structure isn't found (shouldn't happen)
                  element.innerHTML = `<figure class="mb-3"><blockquote class="blockquote mb-0">${htmlContent}</blockquote></figure>`;
              }
          } else {
              element.innerHTML = htmlContent; // Update inner HTML directly
          }
          console.log(`Updated UI for ${type}`);
      } else {
          console.warn(`Element not found for AI content type: ${type}`);
      }
  }

  function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
  }

</script>
{% endblock %}
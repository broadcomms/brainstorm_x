{# app/workshop/templates/workshop_room.html #}
{% extends "main_template.html" %}
{% block title %}Workshop: {{ workshop.title }}{% endblock %}

{% set is_paused = (workshop.status == 'paused') %} {# Renamed for clarity #}
{% set is_organizer_flag = (current_user.user_id == workshop.created_by_id) %} {# Pass organizer flag #}

{% block content %}
<div class="container mt-4">
  <div class="card shadow-sm">
    <!-- ===================== Header ===================== -->
    <div class="card-header bg-success text-white d-flex align-items-center flex-wrap gap-2"> {# Added flex-wrap #}
      <h1 class="h4 mb-0 flex-grow-1">Workshop: {{ workshop.title }}</h1>
      {# Participant Dots Display - Added Here #}
      <div id="user-dots-display" class="me-3" style="display: none;"> {# Hidden initially #}
         <span class="badge bg-light text-dark">Your Dots: <span id="user-dots-count">0</span></span>
      </div>
      <div class="ms-auto d-flex gap-2">
        {# Leave/Pause/Resume/Stop buttons as before #}
        <a id="leave-room-btn" class="btn btn-sm btn-outline-light" href="#"
           data-leave-url="{{ url_for('workshop_bp.view_workshop', workshop_id=workshop.id) }}">
          <i class="bi bi-box-arrow-left"></i> Leave
        </a>
        {% if is_organizer_flag %}
          {% if workshop.status == 'inprogress' %}
          <form id="pause-workshop-form-room" method="POST" class="d-inline" action="{{ url_for('workshop_bp.pause_workshop', workshop_id=workshop.id) }}">
            <button type="submit" class="btn btn-sm btn-warning"><i class="bi bi-pause-fill"></i> Pause</button>
          </form>
          {% elif workshop.status == 'paused' %}
          <form id="resume-workshop-form-room" method="POST" class="d-inline" action="{{ url_for('workshop_bp.resume_workshop', workshop_id=workshop.id) }}">
            <button type="submit" class="btn btn-sm btn-success"><i class="bi bi-play-fill"></i> Resume</button>
          </form>
          {% endif %}
          {% if workshop.status in ['inprogress', 'paused'] %}
          <form id="stop-workshop-form-room" method="POST" class="d-inline" action="{{ url_for('workshop_bp.stop_workshop', workshop_id=workshop.id) }}">
            <button type="submit" class="btn btn-sm btn-danger"><i class="bi bi-stop-fill"></i> Stop</button>
          </form>
          {% endif %}
        {% endif %}
      </div>
    </div>

    <!-- ===================== Body ===================== -->
    <div class="card-body">
      <!-- Top Area: Status & Participants -->
      <div class="row mb-3 align-items-start">
        <div class="col-md-3">
          <p class="mb-1"><strong>Status:</strong>
            <span id="workshop-status-badge" class="badge {{ 'bg-warning text-dark' if is_paused else 'bg-success' }}">
              {{ workshop.status|capitalize }}
            </span>
          </p>
          <p class="text-muted small">Welcome, {{ current_user.first_name or current_user.email.split('@')[0] }}!</p>
        </div>
        <div class="col-md-9">
          <div id="participant-tiles-container" class="d-flex flex-wrap justify-content-end gap-2">
             {# Tiles added by JS #}
          </div>
        </div>
      </div>
      <hr>

      <!-- Flow control area: Organizer Buttons & Timer -->
      <div class="d-flex justify-content-between align-items-center mb-3">
        <div> {# Organizer Controls #}

          
          {% if is_organizer_flag %}
            <form 
                id="begin-intro-form" 
                class="d-inline me-2" 
                action="{{ url_for('workshop_bp.begin_intro', workshop_id=workshop.id) }}" 
                method="POST" 
                style="display: block;">
              <button type="submit" class="btn btn-sm btn-info">Begin Workshop</button>
            </form>
            <button 
            id="next-task-btn" 
              class="btn btn-sm btn-secondary" 
              disabled 
              style="display: none;">
            Next Task
          </button>
          {% endif %}


        </div>
        <div id="timer-display" class="text-end"> {# Timer #}
          <small id="timer-text" class="text-muted h1 font-monospace">--:--</small>
          <div class="progress mt-1" style="height: 5px;">
            <div id="progress-bar" class="progress-bar" role="progressbar" style="width: 0%"></div>
          </div>
        </div>
      </div>
      <hr>

      <!-- ======== 1. AI FACILITATOR ======== -->
      <h4>AI Facilitator</h4>
      <div id="task-area" class="border rounded p-3 bg-light position-relative mb-3" style="min-height:150px;">
        <p id="task-placeholder" class="text-muted">Waiting for the workshop task to begin...</p>
        <div id="task-content" style="display:none;">
          <h5 id="task-title"></h5>
          <div id="task-body"></div> {# Generic container for task content #}
        </div>
        <!-- Pause Overlay -->
        <div id="pause-overlay" class="position-absolute top-0 start-0 w-100 h-100 bg-dark bg-opacity-50 d-flex justify-content-center align-items-center {{ '' if is_paused else 'd-none' }}" style="z-index:10; color: white;">
          <span class="fs-4"><i class="bi bi-pause-circle-fill me-2"></i> Paused</span>
        </div>
      </div>
      <!-- ======== /AI FACILITATOR ======== -->

      <hr>

      <div class="row">
        <!-- ======== 2. LEFT COLUMN (Whiteboard / Clusters / Report) ======== -->
        <div class="col-md-8">
          <h4 id="left-column-title">Whiteboard</h4> {# Title changes dynamically #}

          {# --- Whiteboard for Ideas --- #}
          <div id="sticky-board" class="d-flex flex-wrap gap-2 border rounded p-2 mb-3" style="min-height:200px; background-color:#f8f9fa; display: none;"> {# Hidden initially #}
            <p id="idea-placeholder" class="text-muted small fst-italic w-100 text-center mt-3">Ideas will appear here...</p>
            {# Sticky notes added by JS #}
          </div>

          {# --- Cluster Voting Area --- #}
          <div id="cluster-voting-area" class="mb-3" style="display: none;"> {# Hidden initially #}
             {# Clusters and vote buttons added by JS #}
          </div>

          {# --- Feasibility/Summary Report Area --- #}
          <div id="report-area" class="border rounded p-3 mb-3 bg-light" style="display: none;"> {# Hidden initially #}
             {# Report content added by JS #}
          </div>

          {# --- Idea Input Form --- #}
          <div id="idea-form-container" class="mb-3" style="display: none;"> {# Hidden initially #}
            <form id="idea-form">
              <textarea id="idea-input" class="form-control mb-2" placeholder="Enter your response here…" rows="2" autocomplete="off" required></textarea>
              <button id="idea-submit" type="submit" class="btn btn-primary w-100"><i class="bi bi-send"></i> Submit</button>
            </form>
          </div>
        </div>

        <!-- ======== 3. RIGHT COLUMN (Attendees chat) ======== -->
        <div class="col-md-4">
          <h4>Attendees Chat</h4>
          <div id="chat-messages" class="border rounded p-2 mb-2 bg-light" style="height:300px; overflow-y:scroll;"></div>
          <form id="chat-form">
            <div class="input-group">
              <input id="chat-input" type="text" class="form-control" placeholder="Type message…" autocomplete="off">
              <button class="btn btn-outline-secondary" type="submit">Send</button>
            </div>
          </form>
        </div>
      </div>

    </div> <!-- End card-body -->
  </div> <!-- End card -->
</div> <!-- End container -->

<!-- ===================== Scripts ===================== -->
<script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script> {# Ensure Socket.IO is included #}
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script> {# Add Marked.js for Markdown rendering #}


<script>
  // --- Global State ---
  let currentTaskId = {{ workshop.current_task_id or 'null' }};
  let currentTaskType = null; // Will be set by task events
  let countdownInterval = null;
  let totalDurationForCurrentTask = 0; // MUST be updated when a task starts
  let userDots = 0; // Track user's dots locally
  let userVotes = {}; // Track which clusters user voted for { clusterId: true }

  const workshopId = {{ workshop.id }};
  const userId = {{ current_user.user_id }};
  const isOrganizer = {{ 'true' if is_organizer_flag else 'false' }};
  const roomName = `workshop_room_${workshopId}`;
  let workshopStatus = '{{ workshop.status }}'; // Initial status from server

  // --- DOM Elements (ensure all IDs match HTML) ---
  const elements = {
    taskArea: document.getElementById('task-area'),
    taskPlaceholder: document.getElementById('task-placeholder'),
    taskContent: document.getElementById('task-content'),
    taskTitle: document.getElementById('task-title'),
    // taskDescription: document.getElementById('task-description'),
    taskBody: document.getElementById('task-body'), // Container for dynamic content

    ideaFormContainer: document.getElementById('idea-form-container'),
    ideaInput: document.getElementById('idea-input'),
    ideaSubmitBtn: document.getElementById('idea-submit'),
    ideaForm: document.getElementById('idea-form'),
    stickyBoard: document.getElementById('sticky-board'),
    ideaPlaceholder: document.getElementById('idea-placeholder'),

    clusterVotingArea: document.getElementById('cluster-voting-area'),
    reportArea: document.getElementById('report-area'),
    leftColumnTitle: document.getElementById('left-column-title'),


    progressBar: document.getElementById('progress-bar'),
    timerText: document.getElementById('timer-text'),
    chatForm: document.getElementById('chat-form'),
    chatInput: document.getElementById('chat-input'),
    chatMessages: document.getElementById('chat-messages'),
    participantTilesContainer: document.getElementById('participant-tiles-container'),
    beginIntroForm: document.getElementById('begin-intro-form'),
    nextTaskBtn: document.getElementById('next-task-btn'),
    pauseOverlay: document.getElementById('pause-overlay'),
    statusBadge: document.getElementById('workshop-status-badge'),
    leaveRoomBtn: document.getElementById('leave-room-btn'),
    pauseWorkshopForm: document.getElementById('pause-workshop-form-room'),
    resumeWorkshopForm: document.getElementById('resume-workshop-form-room'),
    stopWorkshopForm: document.getElementById('stop-workshop-form-room'),

    userDotsDisplay: document.getElementById('user-dots-display'),
    userDotsCount: document.getElementById('user-dots-count')

  };




// Helper to read duration from any payload.
function _getDuration(payload) {
  return parseInt(
    payload.duration || payload.task_duration || payload.taskDuration || 0,
    10
  );
}


// --- Timer utility functions for synchronized countdown ---
function clearCountdown() {
  if (countdownInterval) {
    clearInterval(countdownInterval);
    countdownInterval = null;
  }
}

function updateTimerDisplay(seconds) {
  const minutes = Math.floor(seconds / 60).toString().padStart(2, '0');
  const secs    = (seconds % 60).toString().padStart(2, '0');
  elements.timerText.textContent = `${minutes}:${secs}`;
}

function startCountdown(remainingSeconds, originalDuration) {
  clearCountdown();
  let remaining = remainingSeconds;
  totalDurationForCurrentTask = originalDuration;

  // Immediately render the starting point
  updateTimerDisplay(remaining);
  const elapsed0 = originalDuration - remaining;
  elements.progressBar.style.width = ((elapsed0 / originalDuration) * 100) + '%';

  countdownInterval = setInterval(() => {
    remaining -= 1;
    if (remaining < 0) {
      clearCountdown();
      return;
    }
    updateTimerDisplay(remaining);
    const elapsed = originalDuration - remaining;
    const pct     = (elapsed / originalDuration) * 100;
    elements.progressBar.style.width = pct + '%';
  }, 1000);
}

  // --- Utility Functions (postForm, clearCountdown, addStickyNote, updateParticipantTiles, appendChatMessage) ---
  // (Keep these as they were in the previous correct version)
  // ...
  async function postForm(event, form) {
    event.preventDefault();
    const button = form.querySelector('button[type="submit"]');
    const originalHtml = button?.innerHTML;
    if (button) {
      button.disabled = true;
      button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Processing...';
    }

    try {
      const res = await fetch(form.action, {
        method: 'POST',
        body: new FormData(form),
        headers: { 'X-Requested-With': 'XMLHttpRequest' }
      });

      const contentType = res.headers.get("content-type");
      if (contentType && contentType.includes("application/json")) {
        const data = await res.json();
        if (res.ok && data.success) {
          console.log("Form submitted successfully (JSON):", data.message || "Action completed.");
          if (data.redirect_url) {
            window.location.href = data.redirect_url;
          }
          // For pause/resume, rely on socket events + reload
        } else {
          throw new Error(data.message || `Request failed: ${res.status}`);
        }
      } else if (res.ok && res.redirected) {
        window.location.href = res.url;
      } else if (!res.ok) {
        throw new Error(`Request failed: ${res.status}`);
      } else {
        console.log("Form submitted successfully (non-JSON).");
      }
    } catch (err) {
      console.error("Form submission error:", err);
      alert('Error: ' + err.message);
    } finally {
      if (button) {
        button.disabled = false;
        button.innerHTML = originalHtml;
      }
    }
  }

  function clearCountdown() {
    if (countdownInterval) {
      clearInterval(countdownInterval);
      countdownInterval = null;
    }
    elements.progressBar.style.width = '0%';
    elements.timerText.textContent = '--:--';
    totalDurationForCurrentTask = 0;
  }

  function addStickyNote({ user, content, idea_id }) {
    if (!elements.stickyBoard) return;
    elements.ideaPlaceholder.style.display = 'none';
    const note = document.createElement("div");
    // Basic sanitization (replace with a more robust library if needed)
    const safeUser = (user || 'Unknown').replace(/</g, "&lt;").replace(/>/g, "&gt;");
    const safeContent = (content || '').replace(/</g, "&lt;").replace(/>/g, "&gt;");

    note.className = "sticky-note border p-2 bg-warning shadow-sm";
    //note.style.minWidth = '100px';
    note.style.width = '200px';
    note.style.minHeight = '60px';
    note.style.wordWrap = 'break-word';
    note.id = `idea-${idea_id}`; // Ensure idea_id is passed
    note.innerHTML = `<strong class="d-block text-truncate small" title="${safeUser}">${safeUser}</strong><p class="mb-0 small">${safeContent}</p>`;
    elements.stickyBoard.appendChild(note);
  }

 function updateParticipantTiles(participants) {
    if (!elements.participantTilesContainer) return;
    elements.participantTilesContainer.innerHTML = '';
    if (!participants || !participants.length) {
      elements.participantTilesContainer.innerHTML = '<span class="text-muted small fst-italic">No active participants</span>';
      return;
    }
    participants.forEach(p => {
      const tile = document.createElement('div');
      tile.className = 'participant-tile text-center position-relative';
      tile.id = `participant-tile-${p.user_id}`;
      tile.style.width = '60px';

      const profilePic = p.profile_pic_url ? `/static/${p.profile_pic_url}` : "{{ url_for('static', filename='images/default-profile.png') }}";
      const displayName = p.first_name || p.email.split('@')[0];
      const tooltipName = p.first_name ? `${p.first_name} ${p.last_name || ''} (${p.email})`.trim() : p.email;

      tile.innerHTML = `
        <img src="${profilePic}" alt="${displayName}"
             class="rounded-circle mb-1 shadow-sm" style="width:50px;height:50px;object-fit:cover; border: 1px solid #ccc;"
             title="${tooltipName}"
             onerror="this.onerror=null; this.src='{{ url_for('static', filename='images/default-profile.png') }}';">
        <div class="small text-muted text-truncate" style="font-size:0.75rem;line-height:1;max-width: 55px;">
          ${displayName}
        </div>
        ${p.is_organizer
            ? '<span class="badge bg-primary rounded-pill" style="font-size:0.6rem;position:absolute;top:-5px;right:-5px;">Host</span>'
            : ''
        }
      `;
      elements.participantTilesContainer.appendChild(tile);
    });
  }

  function appendChatMessage(userName, message, timestamp, isHistory = false) {
      if (!elements.chatMessages) return;
      const el = document.createElement('div');
      el.classList.add('mb-1', 'small');

      const safeUserName = (userName || 'System').replace(/</g, "&lt;").replace(/>/g, "&gt;");
      const safeMessage = (message || '').replace(/</g, "&lt;").replace(/>/g, "&gt;");

      let timeString = '';
      if (timestamp) {
          try {
              timeString = `<span class="text-muted ms-1" style="font-size: 0.7em;">${new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>`;
          } catch (e) { console.warn("Could not parse timestamp:", timestamp); }
      }

      el.innerHTML = `<strong>${safeUserName}</strong>: ${safeMessage}${timeString}`;
      elements.chatMessages.appendChild(el);
      // Scroll down only for new messages, not history
      if (!isHistory) {
          elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
      }
  }


  // --- New: task‑completion handler ---
  function handleTaskCompletion() {
      // Only act when the introduction (warm‑up) task finishes
      if (currentTaskType === 'warm-up' || currentTaskType === 'introduction') {
          /* Hide “Begin Workshop / Workshop Started” button */
          if (elements.beginIntroForm) {
              elements.beginIntroForm.style.display = 'none';
          }
          /* Show & enable “Next Task” button */
          if (elements.nextTaskBtn) {
              elements.nextTaskBtn.style.display = 'inline-block';
              elements.nextTaskBtn.disabled = false;
              
          }
          /* Tell the server the task has ended (organizer only) */
          if (isOrganizer === 'true' && currentTaskId) {
              socket.emit('task_completed', {
                  workshop_id: workshopId,
                  task_id: currentTaskId,
                  room: roomName
              });
          }
      }
  }








  // --- Core UI Update Functions ---

  function startOrSyncCountdown(remainingSeconds, totalDuration) {
    console.log(`startOrSyncCountdown called with remaining: ${remainingSeconds}, total: ${totalDuration}`);
    clearCountdown(); // Clear any existing timer first

    // Ensure totalDuration is valid and stored
    totalDurationForCurrentTask = parseInt(totalDuration, 10) || 0;
    if (totalDurationForCurrentTask <= 0) {
        console.warn("startOrSyncCountdown: Invalid totalDuration", totalDuration);
        // Optionally display timer as finished if duration is invalid
         elements.timerText.textContent = '00:00';
         elements.progressBar.style.width = '100%';
        return;
    }

    let remaining = Math.max(0, Math.floor(remainingSeconds));

    function updateTimerDisplay() {
        const minutes = Math.floor(remaining / 60);
        const secs = remaining % 60;
        const mm = String(minutes).padStart(2, '0');
        const ss = String(secs).padStart(2, '0');

        elements.timerText.textContent = `${mm}:${ss}`;
        const elapsed = totalDurationForCurrentTask - remaining;
        // Prevent division by zero and ensure pct is between 0 and 100
        const pct = totalDurationForCurrentTask > 0
            ? Math.min(100, Math.max(0, (elapsed / totalDurationForCurrentTask) * 100))
            : 0;
            elements.progressBar.style.width = `${pct}%`;

            // --- Updated countdown logic for warm-up/introduction ---
            if (remaining <= 0) {
                clearCountdown();
                handleTaskCompletion();
                return;
            }
            remaining--;
}
    updateTimerDisplay(); // Show initial time immediately

    if (remaining <= 0) {
        console.log(`Timer already finished for task ${currentTaskId}`);
        handleTimerEnd(); // Handle UI changes for finished timer
        return; // Don't start interval if already finished
    }

    // Only start the interval if the workshop is NOT paused
    if (workshopStatus !== 'paused') {
        console.log("Starting countdown interval...");
        countdownInterval = setInterval(() => {
            remaining--;
            updateTimerDisplay();

            if (remaining < 0) {
                handleTimerEnd();
            }
        }, 1000);
    } else {
         console.log("Countdown not started because workshop is paused.");
    }
  }

  function handleTimerEnd() {
      console.log(`Timer finished for task ${currentTaskId}`);
      // clearCountdown(); // Don't clear totalDuration here
      if (countdownInterval) {
          clearInterval(countdownInterval);
          countdownInterval = null;
      }
      elements.timerText.textContent = '00:00';
      elements.progressBar.style.width = '100%';

    // Disable relevant inputs based on task type
    if (currentTaskType === 'clustering_voting') {
        // Disable all vote buttons
        elements.clusterVotingArea.querySelectorAll('.vote-btn').forEach(btn => btn.disabled = true);
    } else {
        // Disable idea form
        elements.ideaFormContainer.style.display = 'none';
        elements.ideaSubmitBtn.disabled = true;
        elements.ideaInput.disabled = true;
    }

      // Enable and show "Next Task" button for organizer, hide "Begin Workshop"
      if (isOrganizer && elements.nextTaskBtn) {
          elements.nextTaskBtn.disabled = false;
          elements.nextTaskBtn.innerHTML = 'Next Task';
          elements.nextTaskBtn.style.display = 'inline-block';
          if (elements.beginIntroForm) {
              elements.beginIntroForm.style.display = 'none';
          }
      }
  }


  function displayTask(data) {
    console.log("Displaying task:", data);
    if (!data || !data.task_id) {
        console.error("Invalid task data received in displayTask:", data);
        return;
    }
    
    currentTaskId = data.task_id;
    currentTaskType = data.task_type; // Store the task type
    totalDurationForCurrentTask = parseInt(data.duration, 10) || 0;
    console.log(`Set totalDurationForCurrentTask to: ${totalDurationForCurrentTask}`);

    // --- Reset UI ---
    elements.taskPlaceholder.style.display = 'none';
    elements.taskContent.style.display = 'block';
    elements.stickyBoard.style.display = 'none';
    elements.clusterVotingArea.style.display = 'none';
    elements.reportArea.style.display = 'none';
    elements.ideaFormContainer.style.display = 'none';
    elements.userDotsDisplay.style.display = 'none'; // Hide dots display by default
    elements.clusterVotingArea.innerHTML = ''; // Clear previous clusters
    elements.reportArea.innerHTML = ''; // Clear previous report
    elements.stickyBoard.innerHTML = `<p id="idea-placeholder" class="text-muted small fst-italic w-100 text-center mt-3">Ideas will appear here...</p>`; // Reset whiteboard
    elements.ideaPlaceholder = document.getElementById('idea-placeholder'); // Re-select



    // --- Update AI Facilitator Area ---
    elements.taskTitle.textContent = data.title || "Introduction and warm-up";
    elements.taskBody.innerHTML = ''; // Clear previous body

    // --- Populate Task Body based on Type ---
    let instructions = data.instructions || "Please follow the instructions.";
    let description = data.description || data.task_description || "";

    if (currentTaskType === 'warm-up') {
        elements.taskBody.innerHTML = `
            <p class="mb-2">${data.welcome || ''}</p>
            <p class="mb-2">${data.goals || ''}</p>
            <p class="mb-2">${data.rules || ''}</p>
            <hr>
            <p class="mb-2" style="font-weight: bold;">Icebreaker</p>
            <p class="mb-2 fs-5">${data.task || description}</p>
            <p class="mb-2" style="font-weight: bold;">Instruction</p>
            <p class="mb-2">${instructions}</p>`;
        elements.leftColumnTitle.textContent = "Whiteboard";
        elements.stickyBoard.style.display = 'flex'; // Show whiteboard
        elements.ideaFormContainer.style.display = 'block'; // Show idea form
    } else if (currentTaskType === 'brainstorming') {
        elements.taskBody.innerHTML = `
            <p class="fs-5 mb-2">${description}</p>
            <p class="mb-1"><strong>Instructions:</strong></p>
            <p>${instructions}</p>`;
        elements.leftColumnTitle.textContent = "Whiteboard";
        elements.stickyBoard.style.display = 'flex'; // Show whiteboard
        elements.ideaFormContainer.style.display = 'block'; // Show idea form
    } else if (currentTaskType === 'clustering_voting') {
        elements.taskBody.innerHTML = `
            <p class="fs-5 mb-2">${description || 'Ideas have been clustered. Please vote for the clusters you find most promising.'}</p>
            <p class="mb-1"><strong>Instructions:</strong></p>
            <p>${instructions || `Use your dots to vote. You have ${userDots} dots remaining.`}</p>`;
        elements.leftColumnTitle.textContent = "Clusters & Voting";
        elements.clusterVotingArea.style.display = 'block'; // Show voting area
        elements.userDotsDisplay.style.display = 'block'; // Show dots display
        renderClusters(data.clusters || []); // Render the clusters
        // Sync initial dots for the current user
        if (data.participants_dots && data.participants_dots[userId] !== undefined) {
            updateUserDots(data.participants_dots[userId]);
        }
    } else if (currentTaskType === 'results_feasibility') {
        elements.taskBody.innerHTML = `
            <p class="fs-5 mb-2">${description || 'Voting has concluded. Here is the feasibility analysis:'}</p>
            <p class="mb-1"><strong>Instructions:</strong></p>
            <p>${instructions || 'Review the analysis below and prepare for discussion.'}</p>`;
        elements.leftColumnTitle.textContent = "Feasibility Report";
        elements.reportArea.style.display = 'block'; // Show report area
        // Render the report (assuming it's Markdown in data.feasibility_report)
        elements.reportArea.innerHTML = data.feasibility_report ? marked.parse(data.feasibility_report) : '<p class="text-muted">No feasibility report available.</p>';
    } else if (currentTaskType === 'discussion') {
        elements.taskBody.innerHTML = `
            <p class="fs-5 mb-2">${description || 'Let\'s discuss the findings.'}</p>
            <p class="mb-1"><strong>Instructions:</strong></p>
            <p>${instructions || 'Use the chat to share your thoughts.'}</p>`;
        // No specific left column needed, chat is on the right
        elements.leftColumnTitle.textContent = "Discussion";
    } else if (currentTaskType === 'summary') {
        elements.taskBody.innerHTML = `
            <p class="fs-5 mb-2">${data.title || 'Workshop Summary:'}</p>
            <p class="mb-1"><strong>Instructions:</strong></p>
            <p>${instructions || 'Thank you for your participation!'}</p>`;
        elements.leftColumnTitle.textContent = "Workshop Summary";
        elements.reportArea.style.display = 'block'; // Show report area
        // Render the summary (assuming it's Markdown in data.summary_report)
        elements.reportArea.innerHTML = data.summary_report ? marked.parse(data.summary_report) : '<p class="text-muted">No summary available.</p>';
    } else {
        // Fallback for unknown type
        elements.taskBody.innerHTML = `<p>${description || 'Task details unavailable.'}</p><p>${instructions}</p>`;
        elements.leftColumnTitle.textContent = "Task Area";
    }





    // --- Manage Input Form and Organizer Buttons ---
    const isPaused = workshopStatus === 'paused';
    const ideaInputActive = currentTaskType === 'warm-up' || currentTaskType === 'brainstorming';

    elements.ideaInput.value = ''; // Clear previous input


    elements.ideaFormContainer.style.display = ideaInputActive ? 'block' : 'none'; // Show only if idea input is active
    elements.ideaSubmitBtn.disabled = isPaused || !ideaInputActive;
    elements.ideaInput.disabled = isPaused || !ideaInputActive;

    // --- Manage Organizer Buttons ---
    if (isOrganizer) {
        // Disable "Next Task" button until timer finishes
        if (elements.nextTaskBtn) {
            elements.nextTaskBtn.disabled = true;
            elements.nextTaskBtn.style.display = 'inline-block'; // Ensure it's visible
        }
        // Hide "Begin Workshop" button if it exists
        if (elements.beginIntroForm) {
            elements.beginIntroForm.style.display = 'none';
        }
    }




    // --- Start timer ---
    startOrSyncCountdown(totalDurationForCurrentTask, totalDurationForCurrentTask);
  }

  function renderClusters(clusters) {
      elements.clusterVotingArea.innerHTML = ''; // Clear previous
      userVotes = {}; // Reset local tracking of user's votes for this phase

      if (!clusters || clusters.length === 0) {
          elements.clusterVotingArea.innerHTML = '<p class="text-muted">No clusters generated.</p>';
          return;
      }

      clusters.forEach(cluster => {
          const clusterDiv = document.createElement('div');
          clusterDiv.className = 'cluster-item card mb-3 shadow-sm';
          clusterDiv.id = `cluster-${cluster.id}`;
          clusterDiv.innerHTML = `
              <div class="card-body">
                  <h6 class="card-title d-flex justify-content-between align-items-center">
                      <span>${cluster.name || 'Unnamed Cluster'}</span>
                      <span class="badge bg-secondary rounded-pill vote-count" id="vote-count-${cluster.id}">0</span>
                  </h6>
                  ${cluster.description ? `<p class="card-text small text-muted">${cluster.description}</p>` : ''}
                  <button class="btn btn-sm btn-outline-primary vote-btn" data-cluster-id="${cluster.id}" ${workshopStatus === 'paused' ? 'disabled' : ''}>
                      <i class="bi bi-hand-thumbs-up"></i> Vote
                  </button>
                  {# Optional: Add a section to show ideas within the cluster #}
                  {# <div class="ideas-in-cluster small mt-2" style="max-height: 100px; overflow-y: auto;">...</div> #}
              </div>
          `;
          elements.clusterVotingArea.appendChild(clusterDiv);
      });

      // Add event listeners to NEW vote buttons
      elements.clusterVotingArea.querySelectorAll('.vote-btn').forEach(button => {
          button.addEventListener('click', handleVoteButtonClick);
      });
  }

  function handleVoteButtonClick(event) {
      const button = event.currentTarget;
      const clusterId = button.dataset.clusterId;
      if (!clusterId || button.disabled) return;

      // Determine action based on whether user already voted for this locally
      // const action = userVotes[clusterId] ? 'decrement' : 'increment'; // Simple toggle logic

      // Prevent voting if no dots left (client-side check)
      // if (action === 'increment' && userDots <= 0) {
      //     alert("You have no dots left to vote.");
      //     return;
      // }

      console.log(`Emitting submit_vote for cluster ${clusterId}`);
      button.disabled = true; // Temporarily disable button

      socket.emit('submit_vote', {
          room: roomName,
          workshop_id: workshopId,
          user_id: userId,
          cluster_id: parseInt(clusterId),
          // action: action // Send intended action
      });

      // OPTIONAL: Optimistic UI update (update count locally immediately)
      // This can feel faster but might be briefly incorrect if server rejects vote.
      // const voteCountSpan = document.getElementById(`vote-count-${clusterId}`);
      // if (voteCountSpan) {
      //     let currentCount = parseInt(voteCountSpan.textContent) || 0;
      //     voteCountSpan.textContent = action === 'increment' ? currentCount + 1 : Math.max(0, currentCount - 1);
      // }
      // updateUserDots(action === 'increment' ? userDots - 1 : userDots + 1);
      // userVotes[clusterId] = (action === 'increment'); // Update local tracking
  }

  function updateUserDots(newDotCount) {
      userDots = Math.max(0, newDotCount); // Ensure non-negative
      if (elements.userDotsCount) {
          elements.userDotsCount.textContent = userDots;
      }
      // Maybe update voting instructions text too
      const instructionsElement = elements.taskBody.querySelector('p:last-of-type'); // Find instructions paragraph
      if (instructionsElement && currentTaskType === 'clustering_voting') {
           instructionsElement.textContent = `Use your dots to vote. You have ${userDots} dots remaining.`;
      }
  }

  function updateVoteDisplay(clusterId, totalVotes, voterUserId, voterDotsRemaining, actionTaken) {
      // Update the total vote count display for the cluster
      const voteCountSpan = document.getElementById(`vote-count-${clusterId}`);
      if (voteCountSpan) {
          voteCountSpan.textContent = totalVotes;
      }

      // If the update was triggered by the current user, update their dot count and button state
      if (voterUserId === userId) {
          updateUserDots(voterDotsRemaining);

          // Update local vote tracking and button appearance
          const button = elements.clusterVotingArea.querySelector(`.vote-btn[data-cluster-id="${clusterId}"]`);
          if (button) {
               button.disabled = (workshopStatus === 'paused'); // Re-enable button (unless paused)
               if (actionTaken === 'voted') {
                   userVotes[clusterId] = true;
                   button.classList.remove('btn-outline-primary');
                   button.classList.add('btn-primary'); // Make button look 'active'
                   button.innerHTML = '<i class="bi bi-hand-thumbs-up-fill"></i> Voted';
               } else if (actionTaken === 'unvoted') {
                   delete userVotes[clusterId];
                   button.classList.remove('btn-primary');
                   button.classList.add('btn-outline-primary'); // Make button look 'inactive'
                   button.innerHTML = '<i class="bi bi-hand-thumbs-up"></i> Vote';
               }
          }
      }
  }


  function updateWorkshopStatusUI(newStatus) {
    console.log(`Updating UI for status: ${newStatus}`);
    workshopStatus = newStatus;
    const isPaused = workshopStatus === 'paused';
    const isInProgress = workshopStatus === 'inprogress';
    const isTaskActive = !!currentTaskId; // Check if a task is currently loaded

    // Update Status Badge
    elements.statusBadge.textContent = workshopStatus.charAt(0).toUpperCase() + workshopStatus.slice(1);
    elements.statusBadge.className = `badge ${isPaused ? 'bg-warning text-dark' : 'bg-success'}`;

    // Toggle Pause Overlay
    elements.pauseOverlay.classList.toggle('d-none', !isPaused);

    // Enable/Disable Chat Input
    elements.chatInput.disabled = isPaused;
    elements.chatForm.querySelector('button').disabled = isPaused;


    // Enable/Disable Task-Specific Inputs
    const ideaInputActive = currentTaskType === 'warm-up' || currentTaskType === 'brainstorming';
   
    const votingActive = currentTaskType === 'clustering_voting';


    // Enable/Disable Idea Input (only if idea task is active AND not paused)
    elements.ideaInput.disabled = isPaused || !isTaskActive;
    elements.ideaSubmitBtn.disabled = isPaused || !isTaskActive;
    // Ensure idea form container visibility reflects task activity
    elements.ideaFormContainer.style.display = isTaskActive ? 'block' : 'none';

    elements.clusterVotingArea.querySelectorAll('.vote-btn').forEach(btn => btn.disabled = isPaused || !votingActive);
    // Ensure voting area visibility matches task type (handled in displayTask)

    // Show/hide relevant organizer buttons
    if (isOrganizer) {
        if (elements.pauseWorkshopForm) elements.pauseWorkshopForm.style.display = isInProgress ? 'inline' : 'none';
        if (elements.resumeWorkshopForm) elements.resumeWorkshopForm.style.display = isPaused ? 'inline' : 'none';
        if (elements.stopWorkshopForm) elements.stopWorkshopForm.style.display = (isInProgress || isPaused) ? 'inline' : 'none';
        // Begin button: show only if status is inprogress AND no task is active yet
        if (elements.beginIntroForm) elements.beginIntroForm.style.display = (isInProgress && !isTaskActive) ? 'inline' : 'none';
        // Next task button: state managed by timer, but hide if no task active
        if (elements.nextTaskBtn) elements.nextTaskBtn.style.display = isTaskActive ? 'inline-block' : 'none';
    }

    // Handle timer interval on pause/resume
    if (isPaused && countdownInterval) {
        console.log("Clearing countdown interval due to pause.");
        clearInterval(countdownInterval);
        countdownInterval = null;
    } else if (isInProgress && currentTaskId && !countdownInterval) {
        // If resuming, timer sync event should handle restarting the countdown
        console.log("Workshop resumed, waiting for timer_sync...");
    }
  }

  // --- Initialize Socket Connection ---
  const socket = io();

  socket.on('connect', () => {
    console.log(`Socket connected (SID: ${socket.id}), joining room: ${roomName}`);
    socket.emit('join_room', {
      room: roomName,
      workshop_id: workshopId,
      user_id: userId
    });
  });

  socket.on('connect_error', (err) => { /* (Keep as is) */ });
  socket.on('disconnect', (reason) => { /* (Keep as is) */ });


  // --- Socket Event Handlers ---

  socket.on('workshop_status_update', (data) => {
      if (data.workshop_id !== workshopId) return;
      console.log("Received status update:", data.status);
      updateWorkshopStatusUI(data.status);
  });

  // Reload on pause/resume simplifies state management
  ['workshop_paused', 'workshop_resumed'].forEach(evt => {
    socket.on(evt, d => {
      if (d.workshop_id === workshopId) {
        console.log(`Workshop ${evt.split('_')[1]}, reloading page.`);
        document.querySelectorAll('form button[type="submit"]').forEach(btn => btn.disabled = true);
        location.reload();
      }
    });
  });

  socket.on('workshop_stopped', d => { /* (Keep as is) */ });

  // Task start events
  socket.on('introduction_start', (data) => {

    displayTask(data);
    if (isOrganizer) {
      // Hide the Begin button, show Next (disabled until timer end)
      elements.beginIntroForm.style.display = 'none';
      elements.nextTaskBtn.style.display = 'inline-block';
      elements.nextTaskBtn.disabled = true;
    }



      if (data.task_id) {
          console.log("Received introduction_start:", data);
          displayTask(data);

          const originalDuration = _getDuration(data);
          const remaining       = data.remaining_seconds ?? originalDuration;
          startCountdown(remaining, originalDuration);
      } else { console.error("Received introduction_start without task_id:", data); }
  });

  socket.on('task_ready', payload => {
    console.log('[Socket] task_ready', payload);
    displayTask(payload);

    const dur = _getDuration(payload);
    startOrSyncCountdown(dur, dur);

    // Stop spinner but keep disabled until task ends
    if (elements.nextTaskBtn) {
      elements.nextTaskBtn.innerHTML = 'Next Task';
      elements.nextTaskBtn.disabled = true;
    }
});

['clusters_ready','discussion_ready','feasibility_ready','summary_ready']
  .forEach(evt =>
    socket.on(evt, payload => {
      console.log(`[Socket] ${evt}`, payload);
      displayTask(payload);
      const d = _getDuration(payload);
      startOrSyncCountdown(d, d);
      if (elements.nextTaskBtn) {
        elements.nextTaskBtn.innerHTML = 'Next Task';
        elements.nextTaskBtn.disabled = true;
      }
    })
  );

  //socket.on('clusters_ready', (data) => displayTask(data));
  //socket.on('feasibility_ready', (data) => displayTask(data));
  //socket.on('summary_ready', (data) => displayTask(data));
  //socket.on('discussion_ready', (data) => displayTask(data));

  socket.on('timer_sync', (data) => {
      if (data.task_id === currentTaskId) {
          console.log("Received timer_sync:", data);
          // Use totalDurationForCurrentTask stored locally when task started/displayed
          startOrSyncCountdown(data.remaining_seconds, totalDurationForCurrentTask);
      } else {
          console.log("Ignoring timer_sync for different/old task:", data.task_id, "current:", currentTaskId);
      }
  });

  socket.on('whiteboard_sync', (data) => {
      console.log("Received whiteboard_sync:", data);
      if (!elements.stickyBoard) return;
      elements.stickyBoard.innerHTML = ''; // Clear board first
      if (data.ideas && data.ideas.length > 0) {
          // Ensure placeholder exists before trying to hide it
          const placeholder = document.getElementById('idea-placeholder');
          if(placeholder) placeholder.style.display = 'none';
          data.ideas.forEach(idea => addStickyNote(idea));
      } else {
          // Ensure placeholder exists before trying to show it
          const placeholder = document.getElementById('idea-placeholder');
          if(placeholder) placeholder.style.display = currentTaskId ? 'block' : 'none'; // Show only if a task is active
      }
  });

  socket.on('new_idea', data => {
    if (data.task_id === currentTaskId) {
        console.log('New idea received:', data);
        addStickyNote(data);
    } else {
        console.log("Ignoring new_idea for different task:", data.task_id, "current:", currentTaskId);
    }
  });

  // Chat history synchronization
  socket.on('chat_history', (data) => {
      console.log("Received chat_history:", data);
      if (!elements.chatMessages) return;
      elements.chatMessages.innerHTML = ''; // Clear existing messages
      if (data.messages && data.messages.length > 0) {
          data.messages.forEach(msg => appendChatMessage(msg.user_name, msg.message, msg.timestamp, true));
          // Scroll to bottom after loading history
          elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
      }
  });

  // New chat message event
  socket.on('receive_message', d => { /* (Keep as is) */ });

  // Participant list update event
  socket.on('participant_list_update', data => { 
    console.log("Received participant_list_update:", data);
    if (data.workshop_id === workshopId) {
        updateParticipantTiles(data.participants);
    } 
  });

  // --- ADDED: Vote Update Handler ---
  socket.on('vote_update', (data) => {
      console.log("Received vote_update:", data);
      if (data.cluster_id) {
          updateVoteDisplay(data.cluster_id, data.total_votes, data.user_id, data.dots_remaining, data.action_taken);
      }
  });

   // --- ADDED: Sync All Votes Handler (for joins) ---
   socket.on('all_votes_sync', (data) => {
       console.log("Received all_votes_sync:", data);
       if (data.votes && currentTaskType === 'clustering_voting') {
           for (const clusterId in data.votes) {
               const voteCountSpan = document.getElementById(`vote-count-${clusterId}`);
               if (voteCountSpan) {
                   voteCountSpan.textContent = data.votes[clusterId];
               }
           }
           // Also need to update button states based on user's previous votes if possible
           // This requires fetching the user's votes for this task on join
           // Or modifying the 'clusters_ready' payload to include user's vote status per cluster
       }
   });


  // --- ADDED: Handle No Active Task ---
  socket.on('no_active_task', () => {
       console.log("Received no_active_task signal.");
       currentTaskId = null;
       currentTaskType = null;
       elements.taskPlaceholder.style.display = 'block';
       elements.taskContent.style.display = 'none';
       elements.stickyBoard.style.display = 'none';
       elements.clusterVotingArea.style.display = 'none';
       elements.reportArea.style.display = 'none';
       elements.ideaFormContainer.style.display = 'none';
       elements.userDotsDisplay.style.display = 'none';
       clearCountdown();
       if (isOrganizer && elements.beginIntroForm && workshopStatus === 'inprogress') {
           elements.beginIntroForm.style.display = 'inline-block'; // Show Begin button if workshop started but no task active
       }
       if (elements.nextTaskBtn) elements.nextTaskBtn.style.display = 'none';
   });

      // --- ADDED: Moderator Nudge Handler ---
      socket.on('moderator_nudge', (data) => {
       // Check if the nudge is for the current user
       if (data.target_user_id === userId) {
           console.log("[Moderator] Received nudge:", data.message);
           displayNotification(data.message);
       }
   });

   function displayNotification(message) {
       const notificationArea = document.getElementById('notification-area');
       if (!notificationArea) return;

       const notificationId = `notif-${Date.now()}`;
       const notificationDiv = document.createElement('div');
       notificationDiv.id = notificationId;
       notificationDiv.className = 'alert alert-info alert-dismissible fade show shadow-sm'; // Use Bootstrap alert classes
       notificationDiv.setAttribute('role', 'alert');
       notificationDiv.innerHTML = `
           ${message}
           <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
       `;

       notificationArea.appendChild(notificationDiv);

       // Automatically remove the notification after 10 seconds
       setTimeout(() => {
           const element = document.getElementById(notificationId);
           if (element) bootstrap.Alert.getOrCreateInstance(element).close(); // Use Bootstrap's JS to close
       }, 10000); // 10 seconds
   }




  // --- Event Listeners (DOM Ready) ---
  document.addEventListener('DOMContentLoaded', () => {

      // Attach handlers for organizer forms (Pause, Resume, Stop)
      [elements.pauseWorkshopForm, elements.resumeWorkshopForm, elements.stopWorkshopForm].forEach(form => {
          if (form) form.addEventListener('submit', e => postForm(e, form));
      });

      // Leave Room Button
      if (elements.leaveRoomBtn) {
        elements.leaveRoomBtn.addEventListener('click', (e) => {
          e.preventDefault();
          console.log(`Emitting leave_room for ${roomName}`);
          socket.emit('leave_room', { room: roomName, workshop_id: workshopId, user_id: userId });
          // Navigate after emitting (allow socket message to send)
          setTimeout(() => {
              window.location.href = elements.leaveRoomBtn.getAttribute('data-leave-url');
          }, 100); // Small delay
        });
      }
      // Leave room on unload
      window.addEventListener('beforeunload', () => {
          socket.emit('leave_room', { 
            room: roomName, 
            workshop_id: workshopId, 
            user_id: userId 
          });
      });

    // -- Begin Intro Form --
    // Ensure the form exists before attaching the event listener
    if (elements.beginIntroForm) {
      elements.beginIntroForm.addEventListener('submit', async (e) => {
        console.log("Begin Intro form submitted. Preventing default action.");
        e.preventDefault(); // Prevent default form submission

        const form = e.target;
        const button = form.querySelector('button[type="submit"]');
        if (!button) {
          console.error("Submit button not found in begin-intro-form");
          return; // Stop if button isn't found
        }

        button.disabled = true;
        button.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Starting...';

        try {
          const response = await fetch(form.action, {
            method: 'POST',
            headers: {
              'X-Requested-With': 'XMLHttpRequest', // Helps Flask detect AJAX
              'Accept': 'application/json'         // Indicate we prefer JSON response
            },
          });

          // Check if response is ok and content type is JSON before parsing
          const contentType = response.headers.get("content-type");
          if (response.ok && contentType && contentType.includes("application/json")) {
            const data = await response.json();
            if (data.success) {
              console.log("Workshop introduction POST successful. Waiting for socket event.");
            // SUCCESS: Stop the spinner and update button text
              button.innerHTML = 'Workshop Started'; // Update button text
              button.disabled = true; // Disable start button since workshop has started
              // TODO: Enable/disable other buttons based on workshop state
            } else {
              // Server returned JSON but indicated failure
              throw new Error(data.message || 'Failed to start introduction (server error).');
            }
          } else if (!response.ok) {
            // Handle non-JSON errors (like 404, 500 without JSON body)
            const errorText = await response.text(); // Try to get error text
            console.error(`HTTP error ${response.status}: ${errorText}`);
            throw new Error(`HTTP error ${response.status}`);
          } else {
            // Handle unexpected success response that isn't JSON
            console.warn("Received non-JSON success response for begin_intro.");
            // Still rely on socket event, but log this oddity.
          }

        } catch (err) {
          console.error("Begin Intro Error:", err);
          alert('Error starting workshop: ' + err.message);
          // Re-enable button ONLY on error
          button.disabled = false;
          button.innerHTML = 'Begin Workshop';
        }
        // NOTE: No 'finally' block to re-enable button here.
        // On success, the button should be hidden by the UI update
        // triggered by the 'introduction_start' socket event.
      });
      console.log("Attached submit listener to #begin-intro-form"); // Confirm listener attachment
    } else {
      // Log if the form isn't found on page load (e.g., if user is not organizer)
      if (isOrganizer) { // Only log if organizer *should* see the button
        console.log("#begin-intro-form not found on page load, but expected for organizer.");
      }
    }

    if (elements.nextTaskBtn) {
  elements.nextTaskBtn.addEventListener('click', onNextTaskClick);
}

function onNextTaskClick(e) {
  e.preventDefault();
  const btn = elements.nextTaskBtn;
  if (!btn || btn.disabled) return;

  const originalHtml = btn.innerHTML;
  btn.disabled = true;
  btn.innerHTML =
    '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading…';

  fetch(`/workshop/${workshopId}/next_task`, {
    method: 'POST',
    headers: { 'X-Requested-With': 'XMLHttpRequest' }
  })
    .then(r => r.json().catch(() => ({})))
    .then(data => {
      if (!data.success) {
        alert(data.message || 'Failed to advance to next task.');
        btn.disabled = false;
        btn.innerHTML = originalHtml;
      }
      /* on success we wait for task_ready from the server
         to restore the button */
    })
    .catch(err => {
      alert(err.message || 'Network error.');
      btn.disabled = false;
      btn.innerHTML = originalHtml;
    });
}



      // ... (keep beforeunload listener) ...

      // --- Initial UI setup ---
      console.log("[ Init ] DOM Content Loaded. Initializing UI.");
      updateWorkshopStatusUI(workshopStatus);
      console.log(`[ Init ] Initial state: Task ID = ${currentTaskId}, Status = ${workshopStatus}`);
      // The join_room logic in sockets.py should emit necessary events (task, timer, whiteboard)
      // to populate the initial state if a task is already active.


    // Chat Form
    if (elements.chatForm) {
        elements.chatForm.addEventListener('submit', e => {
          e.preventDefault();
          const msg = elements.chatInput.value.trim();
          if (!msg) return;
          socket.emit('send_message', {
            room: roomName,
            message: msg,
            user_id: userId,
            workshop_id: workshopId
          });
          elements.chatInput.value = '';
        });
    }

      // --- Idea Submission Form Listener ---
      if (elements.ideaForm) {
          elements.ideaForm.addEventListener('submit', async (event) => {
              event.preventDefault(); // Prevent default form submission

              const ideaContent = elements.ideaInput.value.trim();
              if (!ideaContent || !currentTaskId || elements.ideaSubmitBtn.disabled) {
                  console.warn("Idea submission blocked (no content, no task, or disabled).");
                  return;
              }

              console.log(`Submitting idea for task ${currentTaskId}: "${ideaContent}"`);
              elements.ideaSubmitBtn.disabled = true;
              const originalButtonHtml = elements.ideaSubmitBtn.innerHTML;
              elements.ideaSubmitBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Submitting...';

              try {
                  const response = await fetch(`/workshop/${workshopId}/submit_idea`, {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json',
                          'X-Requested-With': 'XMLHttpRequest',
                          'Accept': 'application/json'
                      },
                      body: JSON.stringify({
                          task_id: currentTaskId,
                          content: ideaContent
                      })
                  });

                  const contentType = response.headers.get("content-type");
                  if (response.ok && contentType && contentType.includes("application/json")) {
                      const data = await response.json();
                      if (data.success) {
                          console.log("Idea submitted successfully via POST.");
                          elements.ideaInput.value = ''; // Clear input
                      } else {
                          throw new Error(data.message || `Idea submission failed.`);
                      }
                  } else if (!response.ok) {
                      const errorText = await response.text();
                      throw new Error(`HTTP error ${response.status}: ${errorText}`);
                  } else {
                      console.warn("Received non-JSON success response for submit_idea.");
                  }
              } catch (error) {
                  console.error('Error submitting idea:', error);
                  alert(`Error submitting idea: ${error.message}`);
              } finally {
                  // Re-enable button unless paused
                  if (workshopStatus !== 'paused') {
                      elements.ideaSubmitBtn.disabled = false;
                  }
                  elements.ideaSubmitBtn.innerHTML = originalButtonHtml; // Restore original text/icon
              }
          });
          console.log("Attached submit listener to #idea-form");
      } else {
          console.error("#idea-form not found on page load.");
      }



      // --- Initial UI setup ---
      console.log("DOM Content Loaded. Initializing UI.");
      updateWorkshopStatusUI(workshopStatus);
      console.log(`Initial state: Task ID = ${currentTaskId}, Status = ${workshopStatus}`);
      // Socket join logic will trigger state sync events (task, timer, whiteboard/clusters, chat)
  }); // End DOMContentLoaded

</script>
{# --- Load the Agent Chat Interface --- #}
{% include 'service_agent.html' %}
{% endblock %}